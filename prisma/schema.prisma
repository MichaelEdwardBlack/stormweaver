generator client {
  provider = "prisma-client"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String        @id @default(cuid())
  email         String        @unique
  emailVerified DateTime?
  passwordHash  String?
  name          String?
  image         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  accounts      Account[]
  characters    Character[]
  sessions      Session[]
  settings      UserSettings?
}

model UserSettings {
  id            String   @id @default(uuid())
  userId        String   @unique
  diceTextColor String   @default("black")
  diceColor     String   @default("yellow")
  treeView      TreeView
  user          User     @relation(fields: [userId], references: [id])
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model Character {
  id              String               @id @default(cuid())
  name            String
  level           Int                  @default(1)
  visibility      Visibility           @default(owner)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  ancestry        Ancestry?
  startingKit     String?
  marks           Int                  @default(0)
  userId          String
  user            User                 @relation(fields: [userId], references: [id])
  attributes      CharacterAttribute[]
  expertises      CharacterExpertise[]
  itemInstances   ItemInstance[]
  stackableItems  StackableItem[]
  paths           CharacterPath[]
  skills          CharacterSkill[]
  story           CharacterStory?
  talents         CharacterTalent[]
}

model CharacterAttribute {
  id          String    @id @default(cuid())
  characterId String
  attribute   Attribute
  value       Int       @default(0)
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@unique([characterId, attribute])
}

model CharacterSkill {
  id          String    @id @default(cuid())
  skill       Skill
  characterId String
  attribute   Attribute
  rank        Int       @default(0)
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@unique([characterId, skill])
}

model Talent {
  id                String            @id @default(cuid())
  name              String
  description       String
  actionCost        ActionCost
  characterTalents  CharacterTalent[]
  modifierSource    ModifierSource?
  requiredOther     String[]
  requiredSkillId   String?
  requiredSkillRank Int?
  requiredTalents   String[]
  requiredLevel     Int?
}

model CharacterTalent {
  id               String    @id @default(cuid())
  isAncestryTalent Boolean   @default(false)
  applyModifiers   Boolean   @default(true)
  talentId         String
  characterId      String
  character        Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  talent           Talent    @relation(fields: [talentId], references: [id])

  @@unique([characterId, talentId])
}

model ItemTemplate {
  id             String          @id @default(cuid())
  name           String
  type           ItemType
  description    String?
  price          Int?
  acquisition    ItemAcquisition @default(purchase)
  weight         Float
  acquireNote    String?
  modifierSource ModifierSource?
  weapon         Weapon?
  armor          Armor?
  itemInstances  ItemInstance[]
  stackableItems StackableItem[]
}

model Weapon {
  id            String       @id @default(cuid())
  itemId        String       @unique
  isRanged      Boolean      @default(false)
  shortRange    Int?
  longRange     Int?
  reach         Int          @default(5)
  traits        String[]
  expertTraits  String[]

  item          ItemTemplate @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

model Armor {
  id            String       @id @default(cuid())
  itemId        String       @unique
  traits        String[]
  expertTraits  String[]

  item          ItemTemplate @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

model ItemInstance {
  id          String       @id @default(cuid())
  characterId String
  itemId      String

  equipped    Boolean      @default(false)
  slot        EquipSlot?

  character   Character    @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item        ItemTemplate @relation(fields: [itemId], references: [id])

  @@index([characterId])
  @@index([itemId])
}

enum EquipSlot {
  MAIN_HAND
  OFF_HAND
  TWO_HAND
  ARMOR
}

model StackableItem {
  id          String       @id @default(cuid())
  characterId String
  itemId      String

  quantity    Int          @default(1)

  character   Character    @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item        ItemTemplate @relation(fields: [itemId], references: [id])

  @@unique([characterId, itemId])
}

model CharacterPath {
  id             String    @id @default(cuid())
  path           Path
  characterId    String
  level          Int
  isHeroic       Boolean
  isRadiant      Boolean
  isSinger       Boolean
  isStartingPath Boolean
  character      Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
}

model CharacterExpertise {
  id          String        @id @default(cuid())
  name        String
  type        ExpertiseType
  isOrigin    Boolean
  characterId String
  character   Character     @relation(fields: [characterId], references: [id], onDelete: Cascade)
}

model CharacterStory {
  id                   String          @id @default(cuid())
  purpose              String
  obstacle             String
  occupation           String
  relationships        String
  loyalties            String
  personality          String
  appearance           String
  possibleRadiantOrder String
  other                String
  characterId          String          @unique
  goals                CharacterGoal[]
  character            Character       @relation(fields: [characterId], references: [id], onDelete: Cascade)
}

model CharacterGoal {
  id          String         @id @default(cuid())
  description String
  progress    Int            @default(0)
  storyId     String
  story       CharacterStory @relation(fields: [storyId], references: [id], onDelete: Cascade)
}

model Modifier {
  id         String             @id @default(cuid())
  sourceId   String
  targetType ModifierTargetType
  targetKey  String?
  operator   ModifierOperator
  value      Int?
  diceValue  String?
  damageType String?
  createdAt  DateTime           @default(now())
  source     ModifierSource     @relation(fields: [sourceId], references: [id])
}

model ModifierSource {
  id        String        @id @default(cuid())
  type      SourceType
  itemId    String?       @unique
  talentId  String?       @unique
  modifiers Modifier[]
  item      ItemTemplate? @relation(fields: [itemId], references: [id], onDelete: Cascade)
  talent    Talent?       @relation(fields: [talentId], references: [id], onDelete: Cascade)
}

enum TreeView {
  broad
  tall
}

enum Ancestry {
  Human
  Singer
}

enum Visibility {
  owner
  shared
  public
}

enum Attribute {
  strength
  speed
  intellect
  willpower
  awareness
  presence
}

enum Skill {
  athletics
  heavyWeaponry
  agility
  lightWeaponry
  stealth
  thievery
  crafting
  deduction
  lore
  medicine
  discipline
  intimidation
  insight
  perception
  survival
  deception
  leadership
  persuasion
  abrasion
  adhesion
  cohesion
  division
  gravitation
  illumination
  progression
  tension
  transformation
  transportation
}

enum ActionCost {
  ONE_ACTION
  TWO_ACTIONS
  THREE_ACTIONS
  FREE_ACTION
  ALWAYS_ACTIVE
  SPECIAL_ACTION
  REACTION
}

enum ItemType {
  weapon
  armor
  consumable
  tool
  misc
}

enum ItemAcquisition {
  purchase
  talent
  reward
  startingKit
}

enum Path {
  agent
  envoy
  hunter
  leader
  scholar
  warrior
  singer
  dustbringer
  edgedancer
  elsecaller
  lightweaver
  skybreaker
  stoneward
  truthwatcher
  willshaper
  windrunner
}

enum ExpertiseType {
  armor
  cultural
  utility
  specialty
  weapon
}

enum ModifierTargetType {
  ATTRIBUTE
  SKILL
  EXPERTISE
  ARMOR_DEFLECT
  DAMAGE_DICE
  DAMAGE_TYPE
  FOCUS
  INVESTITURE
  PHYSICAL_DEFENSE
  COGNITIVE_DEFENSE
  SPIRITUAL_DEFENSE
  HEALTH
}

enum ModifierOperator {
  ADD
  MULTIPLY
  OVERRIDE
  DIE_STEP
  TIER_SCALING
  LEVEL_SCALING
}

enum SourceType {
  ITEM
  TALENT
}
